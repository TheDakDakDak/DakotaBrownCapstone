<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My ePortfolio</title>
	<link rel="stylesheet" href="../styles.css">
	<style>
        body {
            margin-left: 120px;
            margin-right: 120px;
        }
		h2, h4 {
            text-align: center;
        }
    </style>
</head>
<body>
    <header>
        <h1>Welcome to My ePortfolio</h1>
    </header>
    <nav>
        <ul>
            <li><a href="../index.html">Home/About Me</a></li>
			<li><a href="../originalartifact/originalartifact.html">Original Artifact</a><li>
            <li><a href="../enhancements/enhancements.html">Enhancements</a></li>
            <li><a href="../selfassessment/selfassessment.html">Self-Assessment</a></li>
        </ul>
    </nav>
    <section id="about">
        <h2>Self-Assessment</h2>
		<h4>Foundations</h4>
        <p>If I were to think back on my entire journey toward my degree and asked myself which single course had the greatest impact on me as a programmer, the answer would undoubtedly be the very first course I ever took: Introduction to Programming with C++, at my local community college. I was late to signing up and Professor Colber's class was the only one that had an opening, so I jumped right in. I had taken some general education and math courses previously, but this one was by far the most rigorous. First, we weren't permitted to use an IDE of any kind, not even an advanced notepad application like Notepad++. We had to use Windows notepad and then compile it using MinGW, resulting in the console application. She emphasized that given that we were in the process of learning the very foundations of programming, she wanted us to truly, deeply learn this stuff which would be more difficult if we were to rely on an IDE and all of it's available tools for assistance. Second, before we wrote even one character of code, we had to first develop an English version of the algorithm that would solve the problem at hand in it's entirety. These would be graded as equally important as the code itself. This taught us to think like a computer, it emphasized the fact that the computer knows nothing and we, the programmers need to tell the computer every last thing that it needs to do. This proved to be invaluable to me because it revealed to me what programming is at it's core: breaking down a problem into incredibly tiny steps, and doing all of these steps in the correct order to accomplish a goal. Third, she would lecture for an hour and then provide the remaining hour an a half to us to complete a programming assignment based on what we just learned. One memorable program we had to write was a Mastermind console application. These were done with no Internet allowed and no talking with our classmates. If we wanted help, we had to ask her directly as she wanted to ensure that nobody was given the answer, but instead had to figure it out on their own for the most part.</p>
		<p>These three teaching methodologies left me with an extraordinarily strong grasp on the basic foundations of programming for a first year student. The class was so riveting and involved, that I managed to secure an A in the class despite very tight grading standards. I emailed Professor Colber months afterward with a question regarding the Computer Science education path and at the end of her response she offered to write a glowing letter of recommendation for me should I ever need one. I credit Professor Colber for my strong foundations in the basics as well as my ability to pretty much breeze through the next few classes in community college. She's the second best professor I've ever had at any level of education, behind only my community college Astronomy professor, Paul Sasse who I still occasionally correspond with via email (and who also, unprompted offered a letter of recommendation), but that's another story for another day.</p>
		<p>That'll be the longest writeup for a single class aside from the Capstone, I promise! It was just so integral and foundational to my overall development, that it warranted it's own sizable paragraph. The next course, Advanced Programming was essentially a continuation of the first class and it was here where I received my first exposure to important, but more advanced concepts in programming including sorting and searching algorithms, pointers, 2-dimensional arrays, and was the first time I'd ever practiced Object Oriented Programming. One notably fun project here was developing a working tic-tac-toe console game using 2-dimensional arrays. With my previously outstandingly strong foundation, I took the building blocks that I learned here and set them up on the next layer of my knowlege tower. Their structural integrity wasn't quite as impenetrably solid as the first layer, but I still got a very solid grasp of the material regardless. While the previous class taught me how to instruct a computer to carry out tasks that are essential for more complex tasks, Advanced Programming taught me how to put together those programming pieces to perform more complex tasks like sorting and searching. It also taught me a ton about how memory works on a computer. After Advanced Programming came a more in depth class on Object Oriented Programming, the Data Structures class, and of course, the joys of programming in Assembly Language. And with that, I'd earned my Associate's degree in Computer Science.</p>
		<p>I quickly realized that an A.S. degree alone isn't really all that helpful in securing a job as almost everywhere I looked required a Bachelor's and/or hefty amounts of relevant experience. Around this same time, my brother and his business partner were in the process of a full stack web development project for their business at <a href="http://www.sweatshopbeats.com" target="_blank">Sweatshop Beats</a>. His business partner and web developer, Matt was the one responsible for building this website almost single-handedly, but there was still a ton of work to do, so I offered my help to which they gladly accepted. I had some experience with HTML/CSS previously, but Matt suggested I go over the fundamentals on The Odin Project. The Odin Project is an invaluable tool to learn full stack web development. So I got to work and was quickly up to speed to help with the website. Over the next few months, I helped with tickets of small things that needed to be added or fixed which gave Matt the ability to focus on the heavy lifting. Again, the website is almost entirely Matt's and my brother's doing. I just helped out on the margins. This gave me my first taste of relevant, real-world experience as I learned about React, Typescript, and the sometimes frustrating world of scaling for different devices.</p>
		<h4>Relevant Career-Oriented Experience at SNHU</h4>
		<p>When I started taking classes at SNHU, I immediately noticed that there was a significant change in gears from the program I completed in community college. The focus in CC was to teach me how to program, and it seemed like the bigger focus at SNHU was to teach me how to apply these skills to actually build useful things using the wide variety of different tools I was introduced to. This difference can be likened to Pure vs. Applied Mathematics, as the applied portion focuses heavily on how to take "pure" skills and put them to work doing things that are useful in the real world. Even though SNHU taught me it's fair share of new "pure" skills, this is how I see much of my tenure at SNHU: as Applied Computer Science rather than theory alone.</p>
		<p>This was evident in the very first CS class I took here in Operating Platforms. We were tasked with building the framework for an application for an imaginary company. This not only focused on how to figure out how to write the underlying code, it also addressed customer needs in a prominent way. Each step along the way, we had to do a seperate writeup detailing how this was meeting the needs specified by this customer. So now, we weren't simply coding for the sake of coding, we were coding for an intended purpose and had to pay keen attention to the requirements of all stakeholders involved in a project as well. In another class I took that term, Software Security, it too put a lot of focus on the stakeholders and introduced me to things like OWASP (Open Worldwide Application Security Project) as well as SQL injection which is something I'd known about for a long time, but never fully understood how it worked until this course. The last of the "easy" courses was Software Testing, Automation, and Quality Assurance which covered important concepts like unit and integration testing. It was here that I learned many of the skills that were so valuable to me as I troubleshooted in this capstone project. So at this point, I had the basics of programming down, and I'd learned how to apply these to put together a basic, standalone project that meets the expectations and requirements of a shareholder. In this skill base, I could also apply sophisticated testing methods to ensure quality as well as implement common procedures to ensure it's security from external threats. Plus I'd completed Software Development Lifecycle and System Analysis and Design as well. </p>
		<p>But at this point, I still didn't quite have the skills to develop an application involving the full stack. Next up then would be two very in-depth courses in Client/Server Development and Full Stack Development I. I'd imagined that we'd be using SQL which I was somewhat familiar with the basics of, but instead we were introduced to entirely different kind of database management tool in NoSQL and used MongoDB specifically. This is really where I hammered down my skills in working with databases as the database work in these courses was extensive. I found it very challenging at first as to make a database work seamlessly with the program, everything needs to be "wired" perfectly. If there are any issues whatsoever, they are often difficult to diagnose, and cause major problems - usually causing the entire project to not work. While Client/Server development's focus was on primarily the backend, Full Stack Development integrated the backend with a complex frontend as well. Learning how to develop the backend, the frontend and then combine them seamlessly, while difficult was a crucial skill to learn and prepared me well for my next course - and the foundation of my Capstone project: Mobile Architecture and Programming. I'm not going to go over that course quite yet, because I'll cover it in-depth in the Capstone section of this self-assessment.</p>
		<p>After the Mobile Architecture and Programming course, I took two of the most complicated courses in the curriculum during the same term, but it wasn't really all that bad. These courses were Computational Graphics and Visualization and Current and Emerging Trends in Computer Science. These were a little bit different than the other classes because they didn't teach fundamental topics that would be of use in just about every compsci related career, these were more about narrow specializations. In CGaV, we used OpenGL with a large dose of Linear Algebra to create a 3-d scene composed of a few objects of our choice. CaETiCS was primarily concerned with how artificial intelligence and machine learning works. Our final project involved building a program where a virtual pirate learns to navigate a maze to find the hidden treasure. These were both pretty much standalone courses that mainly apply to their specialization, and while I don't have any interest in using OpenGL in the future, I'm still grateful that I learned the basics because taking these classes helped me become a more well-rounded student of the subject of Computer Science.</p>
		<h4>The Capstone</h4>
		<p>The grand finale of a Bachelor's degree. The Capstone is all about taking the aforementioned skills gained from this program and applying them to one last project before graduation. We were to take one or more of our previous projects and make 3 enhancements to them demonstrating compentency in software engineering, data structures and/or algorithms, and databases. For my Capstone project, I used one single previous project and enhanced it three times to produce the final project. The artifact I used was originally created in the Mobile Architecture and Design course. The artifact was a weight tracker app where the user would first create an account with the login credentials being stored in an SQLite database and then logging in with these credentials. One logged in, the user is taken to the main page where they can set a goal weight (stored in the database) and add their current weight (also stored in the database). The list is then reloaded and displays all of their entered weights next to the date. Once the goal weight is met, they are notified via SMS that they have reached their goal. In my initial project, the SMS function was in place, however it wasn't functional as I couldn't figure out what phone number to send it to.</p>
		<p>This original project in a way was like a Pre-Capstone project. It included all of the fundamental skills that I'd learned in earlier courses, and they all came together to create this final project for the Mobile Programming class. Most notably the skills learned in Client/Server Development and Full Stack Development courses helped me to develop the backend database and wire that correctly with an intuitively designed front end user interface. As I mentioned earlier, it also made good use of what I learned in the Software Testing class to debug and troubleshoot any errors I came across in developing the app. All of the previous courses focused attention on the fact that there are other stakeholders as well including the user, so these ideas were also put to use and kept in the front of my mind as I worked on it. And of course, none of this could've even been started without the very foundational knowledge of programming itself that I first learned in community college.</p>
		<p>So onto the Capstone itself. The first task was to take that main weights list and add two columns, one for change in weight since the last entry, and the other for total weight still needed to acheive the goal weight. In doing this, I demonstrated skills in software engineering in that I took existing software and transformed it to provide more valuable to the user. It demonstrates skill in modifying a user interface to include extra information while still being aesthetically pleasing and maintaining the integrity of the existing information. This didn't only involve a simple tweak to the xml file, it also involved modifying the Java code itself to keep track of certain data items as it iterates through the database and then display this information nicely to the user.</p>
		<p>The second task was to implement an algorithm to create an entirely new activity on the application. This was the implementation of the Weight Loss Calculator. It takes input from the user for several pieces of data including their weight, height, age, gender, activity level, amount of weight they'd like to lose, and how fast they'd like to lose it, and transforms all of those inputs into a single output which tells the user the total number of calories they can eat daily to reach their weight loss goal. This certainly demonstrates competency in the realm of algorithms. One of the most common needs for an algorithm is the need to transform data in some way, and that's exactly what this algorithm does. It accepts 7 pieces of data that a user is already aware of and transforms them into a different piece of data that the user is not aware of and can't quickly calculate on their own, but that the user needs.</p>
		<p>And lastly, the third task builds directly on top of what was completed in the second task and is intended to show competency in working with databases. For this portion, an activity for a user profile was set up. This takes inputs from the user in the form of their preferred name, height, age, and gender and stores them in the database. Then when they go to use the weight loss calculator, all of this information will be extracted from the database and prepopulated for the user in the corresponding fields. This demonstrates competency in working with databases because it involves adding brand new columns to the database in order to store additional, needed information. It actually includes the first 3 portions of CRUD, Create, Read, and Update. Delete is not necessary in this scenario because if anything needs to be changed, it's simply updated via the profile page and there is no need for a delete option. Create is covered when they initially enter this information into the profile page, Read is covered when this information is pulled from the database and used to populate the fields in the weight loss calculator. And update is covered if a user needs to change their information in the profile page.</p>
		<h4>Why all Course Outcomes are Met</h4>
		<h5>Outcome 1: Employ strategies for building collaborative environments that enable diverse audiences to support organizational decision making in the field of computer science</h5>
		<p>I created a half hour long code review which you can download <a href="https://drive.google.com/file/d/14fFfkxyp_uJ-CIwQ74DJDq05rYFL1TP0/view?usp=sharing" target="_blank">here</a> for an earlier assignement in this course where I discussed strategies to organize my code to make it more readable to anyone else working on it. I also discussed the need for commenting, specifically to note what certain functions do, because there were precisely zero comments in my original weight tracker app codebase. During this capstone, I organized certain methods in a more intuitive format and added comments (particularly to the databasehelper methods) describing what many methods do and also in places where it might be unclear why something is being done. This is important because if I ever decided to improve this app further, market it, and had others working on it, the codebase could be quite difficult to navigate without proper organization and documentation. Additionally, all stakeholders were kept in mind from start to finish during the creation of this project. This project has just two stakeholders currently, myself and the user. One example of me keeping the stakeholders in mind is by allowing the user to still edit their information in the Weight Loss Calculator even if it was prepopulated in case they'd like to enter information on behalf of someone else. And if someone else sees the app at work, they may want to download it themselves and thus become another stakeholder.</p>
		<p>By the project directions, I wasn't sure if this part should include only work from the capstone, or everything mentioned in my self-assessment, so just in case I'll be covering reasons outside of the Capstone as well. Most notably would be my work at Sweatshop Beats, and also the work I did in the Software Testing, Automation, and Quality assurance in testing modules and completed projects while ensuring that they meet all of the goals of the stakeholders.</p>
		<h5>Outcome 2: Design, develop, and deliver professional-quality oral, written, and visual communications that are coherent, technically sound, and appropriately adapted to specific audiences and contexts</h5>
		<p>This is also partially covered in my code review submitted in week 2. Professor Bryant was my audience, so the presentation consisted of my full range of technical language. Had it been to a less technical audience, like a business department, it would've used less jargon. My pages on this Git Page including Original Artifact and Enhancements also demonstrate this ability well as my audience isn't only Professor Bryant, but all possible employers who may or may not have programming experience. While there is some technical jargon on my webpages, it's limited and everything on this Git Page is also understandable to the audience of people who may consider hiring me. If we also include the narratives that I've submitted in earlier weeks, it's clear that I certainly meet the outcome of being able to deliver professional quality oral, written, and visual communications.</p>
		<h5>Outcome 3: Design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices</h5>
		<p>This is clearly demonstrated in all three of my enhancements for my project, so it doesn't really need much elaboration here. Take for example the Weight Loss Calculator. There existed a problem for the user that they needed to know how many calories they could eat per day. Through logic and programming, and algorithm was created to solve this problem for them. I developed an extremely strong foundation in this outcome dating all the way back to that first compsci course where Professor Colber had us write down every last computer instruction in English (the algorithm) before doing any coding at all.</p>
		<h5>Outcome 4: Demonstrate an ability to use well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that deliver value and accomplish industry-specific goals</h5>
		<p>This outcome too is also clearly demonstrated in the enhancements and also needs little explaining. But as I explained in my narratives, I used several testing techniques to debug the code and make sure it works correctly such as inserting points into the code that'll generate an entry on logcat if they're reached which helped me to figure out when code is unreachable. This app also uses very standard interface design that is very common in the industry. Being that it's commonly used, it's also very intuitive to the user and delivers value to them as they're able to accomplish their goals of tracking their weight and calculating calories via this application.</p>
		<h5>Outcome 5: Develop a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources</h5>
		<p>This outcome is also met with this Capstone and is readily evident in the application itself. This application doesn't connect to the Internet, so it doesn't need any overly sophisticated security methods, but bad actors on the Internet aren't the only threat. Threats can come from people in the same room as you with access to your phone. That's why this app includes a fully functional login system with input validation and authentication and will not allow any user in who has not created an account. If they don't have the correct password, they can't get into your account and therefore can't access any of your weight data which to many people may be considered sensitive information. The application also has a few features included that protect the user from themselves. When they click the delete button for their weight entries, they are first presented with a warning message that they must accept before the data is deleted. With this feature in place, it is far less likely that the user will experience any unintended data loss. Also of note is that I learned much about software security in the class of the same name. One example being using paramaterized queries to prevent SQL injection attacks by first sanitizing the data before processing it.</p>
		
	</section>
	<br><br><br><br>
    <footer>
        <p>© 2024 My ePortfolio</p>
    </footer>
</body>
</html>